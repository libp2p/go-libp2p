package config

import (
	"fmt"
	"reflect"

	"go.uber.org/fx"
)

// typedFxOption is an fx.Option with some basic type checking done at runtime.
// It can only be generated by NewTypedFxOption, which validates with reflection
// that the provided Generic is indeed returned by the constructor.
type typedFxOption[T any] struct{ fx.Option }

// option implements TypedFxOption.
func (t *typedFxOption[T]) option() fx.Option {
	return t.Option
}

// TypedFxOption is an opaque interface that represents an fx.Option that
// constructs the specified type. You can create a TypedFxOption with
// NewTypedFxProvide.
type TypedFxOption[T any] interface {
	option() fx.Option
}

var _ fx.Option = (*typedFxOption[any])(nil)
var _ TypedFxOption[any] = (*typedFxOption[any])(nil)

func Must[T any](t T, err error) T {
	if err != nil {
		panic(err)
	}
	return t
}

func NewTypedFxSupply[T any](t T, annotations ...fx.Annotation) *typedFxOption[T] {
	return &typedFxOption[T]{fx.Supply(fx.Annotate(t, annotations...))}
}

func NewTypedFxProvide[T any](constructor any, annotations ...fx.Annotation) (*typedFxOption[T], error) {
	if err := validateConstructor[T](constructor); err != nil {
		return nil, err
	}
	typ := reflect.TypeOf(constructor)
	isVariadic := typ.IsVariadic()

	var params []string
	if isVariadic {
		tag := FxTagForType[T]()
		numParams := typ.NumIn()

		// tag the last variadic tag
		params = make([]string, numParams)
		params[len(params)-1] = tag
	}

	annotations = append(annotations, fx.ParamTags(params...))
	return &typedFxOption[T]{
		fx.Provide(fx.Annotate(constructor, annotations...)),
	}, nil
}

// SupplyConstructorOpts supplies the provided opts to the constructor of T
func SupplyConstructorOpts[T any](opts ...any) fx.Option {
	return fx.Supply(fx.Annotate(opts, fx.ResultTags(FxTagForType[T]())))
}

func FxTagForType[T any]() string {
	return fmt.Sprintf(`group:"constructor_opt_%T"`, new(T))
}

func validateConstructor[T any](constructor any) error {
	constructorType := reflect.TypeOf(constructor)

	// Validate that constructor is a function
	if constructorType.Kind() != reflect.Func {
		return fmt.Errorf("constructor must be a function, got %v", constructorType)
	}

	// Get the target type T
	targetType := reflect.TypeOf((*T)(nil)).Elem()

	// Check number of return values
	numOut := constructorType.NumOut()
	if numOut == 0 {
		return fmt.Errorf("constructor must return at least one value")
	}

	// Get the first return type
	firstReturnType := constructorType.Out(0)

	// Check if constructor returns the correct type patterns
	var valid bool

	if numOut == 1 {
		// Pattern: returns T or struct embedding fx.Out with T
		valid = validateReturnType(firstReturnType, targetType)
	} else if numOut == 2 {
		// Pattern: returns (T, error) or struct embedding fx.Out with (T, error)
		secondReturnType := constructorType.Out(1)
		errorType := reflect.TypeOf((*error)(nil)).Elem()

		if secondReturnType.Implements(errorType) {
			valid = validateReturnType(firstReturnType, targetType)
		}
	}

	if !valid {
		return fmt.Errorf("constructor return type %v does not match expected type %v", firstReturnType, targetType)
	}

	return nil
}

// validateReturnType checks if returnType matches targetType directly or
// if returnType is a struct embedding fx.Out that contains targetType
func validateReturnType(returnType, targetType reflect.Type) bool {
	// Direct type match
	if returnType == targetType {
		return true
	}

	// Check if return type is a struct that embeds fx.Out
	if returnType.Kind() != reflect.Struct {
		return false
	}

	// Check if struct embeds fx.Out
	var embedsFxOut bool
	fxOutType := reflect.TypeOf(fx.Out{})

	for i := 0; i < returnType.NumField(); i++ {
		field := returnType.Field(i)
		if field.Anonymous && field.Type == fxOutType {
			embedsFxOut = true
			break
		}
	}

	if !embedsFxOut {
		return false
	}

	// Check if the struct has a field of target type
	for i := 0; i < returnType.NumField(); i++ {
		field := returnType.Field(i)
		if !field.Anonymous && field.Type == targetType {
			return true
		}
	}

	return false
}
